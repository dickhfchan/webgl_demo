<!DOCTYPE html>
<html lang="en">
	<head>
		<title>demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;

				text-align: center;
				font-size: 14px;
				cursor: pointer;
			}
			#finger{
				display:none;
				width: 20px;
				height: 20px;
				position: absolute;
				left: 50%;
				top: 50%;
			}

			dialog{
				background-color: #fdf6ec;
				border-color: #faecd8;
				color: #e6a23c;
				top: 150px;
				width: 250px;
				border-radius: 10px;
				border-width: 1px;
				transition: opacity .3s,transform .4s,-webkit-transform .4s;
			}

		</style>
	</head>
	<body>
		

		<img id="finger" src="./images/finger.png"  alt="" />
		<div id="blocker">
			<div id="instructions">
				<p style="font-size:36px">
					Click to start
				</p>
				<p>
					Move: WASD<br/>
					Look: MOUSE
				</p>
			</div>
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { PointerLockControls } from './jsm/controls/PointerLockControls.js';

			import { FBXLoader } from './jsm/loaders/FBXLoader.js';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';


			let camera, scene, renderer, controls,material0;
			let texturePlante0,texturePlante1,texturePlante2,texturePlante3;
			let fbxModels;

			const objects = [];

			let raycaster;

			let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let canJump = false;

			let prevTime = performance.now();
			const velocity = new THREE.Vector3();
			const direction = new THREE.Vector3();
			const vertex = new THREE.Vector3();
			const color = new THREE.Color();

			init();
			animate();
			createPanel();


			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 10;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );


				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 1 );
				light.position.set( 1, 1, 1 );
				scene.add( light );
				

				controls = new PointerLockControls( camera, document.body );

				const blocker = document.getElementById( 'blocker' );
				const instructions = document.getElementById( 'instructions' );
				const finger = document.getElementById( 'finger' );

				instructions.addEventListener( 'click', function () {

					controls.lock();

				} );

				controls.addEventListener( 'lock', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';

				    document.body.addEventListener('mousedown', onMouseclick, false);
				    finger.style.display = 'block'
				} );

				controls.addEventListener( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';

					document.body.removeEventListener('mousedown', onMouseclick, false);
					finger.style.display = 'none'

				} );

				scene.add( controls.getObject() );

				const onKeyDown = function ( event ) {

					switch ( event.code ) {

						case 'ArrowUp':
						case 'KeyW':
							moveForward = true;
							break;

						case 'ArrowLeft':
						case 'KeyA':
							moveLeft = true;
							break;

						case 'ArrowDown':
						case 'KeyS':
							moveBackward = true;
							break;

						case 'ArrowRight':
						case 'KeyD':
							moveRight = true;
							break;

						case 'Space':
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};

				const onKeyUp = function ( event ) {

					switch ( event.code ) {

						case 'ArrowUp':
						case 'KeyW':
							moveForward = false;
							break;

						case 'ArrowLeft':
						case 'KeyA':
							moveLeft = false;
							break;

						case 'ArrowDown':
						case 'KeyS':
							moveBackward = false;
							break;

						case 'ArrowRight':
						case 'KeyD':
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown );
				document.addEventListener( 'keyup', onKeyUp );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

					// model
				initFbxs();
				

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize );
				

			}
			function initFbxs() {
				texturePlante0 = THREE.ImageUtils.loadTexture("models/fbx/4k1_Diffuse.jpeg",null,function(t){});
					texturePlante1 = THREE.ImageUtils.loadTexture("models/fbx/4k2_Diffuse.jpeg",null,function(t){});
					texturePlante2 = THREE.ImageUtils.loadTexture("models/fbx/4k3_Diffuse.jpeg",null,function(t){});
					texturePlante3 = THREE.ImageUtils.loadTexture("models/fbx/WTS_BG2_baked.jpg",null,function(t){});
					texturePlante0.wrapS = texturePlante0.wrapT = THREE.RepeatWrapping;
					texturePlante1.wrapS = texturePlante1.wrapT = THREE.RepeatWrapping;
					texturePlante2.wrapS = texturePlante2.wrapT = THREE.RepeatWrapping;
					texturePlante3.wrapS = texturePlante3.wrapT = THREE.RepeatWrapping;

					const loader = new FBXLoader();
					loader.load( 'models/fbx/WTS_v1.fbx', function ( object ) {
						console.log(object)
						fbxModels = object;
	
						var child0 = object.children[0];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante0
						});
						child0.material=material;
						child0.material.needsUpdate = true;
						material0 = material;
	
						console.log(child0)
					
	
						var child1 = object.children[1];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante0
						});
						child1.material=material;
						child1.material.needsUpdate = true;
						
						console.log(child1)
						if ( child1.isMesh ) {
							child1.castShadow = true;
							child1.receiveShadow = true;
						};
	
						var child2 = object.children[2];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante0
						});
						child2.material=material;
						console.log(child2)
						if ( child2.isMesh ) {
							child2.castShadow = true;
							child2.receiveShadow = true;
						};
	
	
						var child3 = object.children[3];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante3
						});
						child3.material=material;
						if ( child3.isMesh ) {
							child3.castShadow = true;
							child3.receiveShadow = true;
						};
	
						object.traverse( function (child){
							if(child instanceof THREE.Mesh){
							}
						});
	
						scene.add( object );
					} );

			}

			function createPanel() {
				function f1() {
					fbxModels.traverse( function (child){
						let material = child.material;
						material.opacity = 10;
						material.normalScale = new THREE.Vector3( 0.01, 0.01);
						material.roughness = 0;
					});
				}
	
				function f2() {
					let texture = THREE.ImageUtils.loadTexture("models/fbx/4k2_Diffuse.jpeg",null,function(t){});
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

					console.log(fbxModels)

					for(var i=0;i<fbxModels.children.length-1;i++){
						let material = fbxModels.children[i].material;
						texture.needsUpdate = true; 
						material.map = texture;
						material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
						material.opacity = 1.5;
						material.roughness = 1;
					}
				}
				function f3() {
					let texture = THREE.ImageUtils.loadTexture("models/fbx/4k3_Diffuse.jpeg",null,function(t){});
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

					for(var i=0;i<fbxModels.children.length-1;i++){
						let material = fbxModels.children[i].material;
						texture.opacity = 10;
						texture.needsUpdate = true; //maybe useless too ?
						material.map = texture;
						material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
						//material.map.repeat.set(10, 10);
					}
				}

				const params = {
					color:0xffffff,
					clear: function () {
						f1();
					},
					clear1: function () {
						f2();
					},
					clear2: function () {
						f3();
					}
				};
				const panel = new GUI();
				panel.addColor(params, 'color').name('dress color').onChange(function(val){
					material0.color.setHex( val );
				});
				//panel.add(params, 'clear').name('油面反光材质');
				panel.add(params, 'clear1').name('半透明纱网材质');
				panel.add(params, 'clear2').name('图案切换');
				// panel.add(params, 'clear1');
			}
			

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				render();
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}

			function render(){
				controlsRender();
			}

			 
    // 鼠标双击触发的方法
    function onMouseclick(event) {
 
        // 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前
        var intersects = getIntersects(event);
 
        // 获取选中最近的 Mesh 对象
        if (intersects.length != 0 && intersects[0].object instanceof THREE.Mesh) {
            let selectObject = intersects[0].object;
			alert("click on "+selectObject.name);

			console.log(selectObject)
        } else {
            alert("未选中 Mesh!");
        }
    }

			 // 获取与射线相交的对象数组
			 function getIntersects(event) {
				event.preventDefault();
				console.log("event.clientX:"+event.clientX)
				console.log("event.clientY:"+event.clientY)
		 
				// 声明 raycaster 和 mouse 变量
				var raycaster = new THREE.Raycaster();
				var mouse = new THREE.Vector2();
		 
				// 通过鼠标点击位置,计算出 raycaster 所需点的位置,以屏幕为中心点,范围 -1 到 1
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
		 
				//通过鼠标点击的位置(二维坐标)和当前相机的矩阵计算出射线位置
				raycaster.setFromCamera(mouse, camera);
		 
				// 获取与射线相交的对象数组，其中的元素按照距离排序，越近的越靠前
				var intersects = raycaster.intersectObjects(scene.children);
		 
				//返回选中的对象
				return intersects;
			}


			function controlsRender(){
				const time = performance.now();

				if ( controls.isLocked === true ) {

					

					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					const intersections = raycaster.intersectObjects( objects, false );

					const onObject = intersections.length > 0;

					const delta = ( time - prevTime ) / 500;

					velocity.x -= velocity.x * 5.0 * delta;//移动速度
					velocity.z -= velocity.z * 5.0 * delta;//移动速度


					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					if ( onObject === true ) {

						velocity.y = Math.max( 0, velocity.y );
						canJump = true;

					}

					controls.moveRight( - velocity.x * delta );
					controls.moveForward( - velocity.z * delta );

					controls.getObject().position.y += ( velocity.y * delta ); // new behavior

					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

						canJump = true;
					}

				}
				prevTime = time;
				impactCheck()
			}

			//碰撞检测
			function impactCheck(){
				//(-515,-550)(515,550)
				let position = controls.getObject().position;
				if(position.x<-515){
					controls.getObject().position.x= -515;
				}
				if(position.x>515){
					controls.getObject().position.x= 515;
				}
				if(position.z<-550){
					controls.getObject().position.z= -550;
				}
				if(position.z>550){
					controls.getObject().position.z= 550;
				}
			}

		</script>
	</body>
</html>
