<!DOCTYPE html5>
<html lang="en">
	<head>
		<title>demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
	
			#finger{
				display:none;
				width: 20px;
				height: 20px;
				position: absolute;
				left: 50%;
				top: 50%;
			}

			dialog{
				background-color: #fdf6ec;
				border-color: #faecd8;
				color: #e6a23c;
				top: 150px;
				width: 250px;
				border-radius: 10px;
				border-width: 1px;
				transition: opacity .3s,transform .4s,-webkit-transform .4s;
			}
			#lock-model{
				position: absolute;
				margin-top:10px;
				margin-left: 10px;
			}

		</style>
	</head>
	<body>
		

		<img id="finger" src="./images/finger.png"  alt="" />
		<button id='lock-model'>Enter Lock Model</button>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { PointerLockControls } from './jsm/controls/PointerLockControls.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			import { FBXLoader } from './jsm/loaders/FBXLoader.js';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';


			let gui = new GUI();


			const constants = {
				combine: {
				  "THREE.MultiplyOperation": THREE.MultiplyOperation,
				  "THREE.MixOperation": THREE.MixOperation,
				  "THREE.AddOperation": THREE.AddOperation,
				},
		
				side: {
				  "THREE.FrontSide": THREE.FrontSide,
				  "THREE.BackSide": THREE.BackSide,
				  "THREE.DoubleSide": THREE.DoubleSide,
				},
			  };
		
			  function getObjectsKeys(obj) {
				const keys = [];
		
				for (const key in obj) {
				  if (obj.hasOwnProperty(key)) {
					keys.push(key);
				  }
				}
		
				return keys;
			  }
		
			  const textureLoader = new THREE.TextureLoader();
			  const cubeTextureLoader = new THREE.CubeTextureLoader();
		
			  const envMaps = (function () {
				const path = "./textures/cube/";
				const format = ".jpeg";
				const urls = [
				  path + "px" + format,
				  path + "nx" + format,
				  path + "py" + format,
				  path + "ny" + format,
				  path + "pz" + format,
				  path + "nz" + format,
				];
		
				const reflectionCube = cubeTextureLoader.load(urls);
		
				const refractionCube = cubeTextureLoader.load(urls);
				refractionCube.mapping = THREE.CubeRefractionMapping;
		
				return {
				  none: null,
				  reflection: reflectionCube,
				  refraction: refractionCube,
				};
			  })();
		
			  const diffuseMaps = (function () {
				const color1 = textureLoader.load("./textures/color1/diffuse.jpg");
				color1.wrapS = THREE.RepeatWrapping;
				color1.wrapT = THREE.RepeatWrapping;
				color1.repeat.set(10, 10);
				const color2 = textureLoader.load("./textures/color2/diffuse.jpg");
				color2.wrapS = THREE.RepeatWrapping;
				color2.wrapT = THREE.RepeatWrapping;
				color2.repeat.set(10, 10);
		
				return {
				  none: null,
				  color1: color1,
				  color2: color2,
				};
			  })();
			  const normalMaps = (function () {
				const color1 = textureLoader.load("./textures/color1/normal.jpg");
				color1.wrapS = THREE.RepeatWrapping;
				color1.wrapT = THREE.RepeatWrapping;
				color1.repeat.set(10, 10);
				const color2 = textureLoader.load("./textures/color2/normal.jpg");
				color2.wrapS = THREE.RepeatWrapping;
				color2.wrapT = THREE.RepeatWrapping;
				color2.repeat.set(10, 10);
		
				return {
				  none: null,
				  color1: color1,
				  color2: color2,
				};
			  })();
			  const metalnessMaps = (function () {
				const color1 = textureLoader.load(
				  "./textures/color1/metalness.jpg"
				);
				color1.wrapS = THREE.RepeatWrapping;
				color1.wrapT = THREE.RepeatWrapping;
				color1.repeat.set(10, 10);
				const color2 = textureLoader.load(
				  "./textures/color2/metalness.jpg"
				);
				color2.wrapS = THREE.RepeatWrapping;
				color2.wrapT = THREE.RepeatWrapping;
				color2.repeat.set(10, 10);
		
				return {
				  none: null,
				  color1: color1,
				  color2: color2,
				};
			  })();
			  const roughnessMaps = (function () {
				const color1 = textureLoader.load(
				  "./textures/color2/roughness.jpg"
				);
				color1.wrapT = THREE.RepeatWrapping;
				color1.wrapS = THREE.RepeatWrapping;
				color1.repeat.set(10, 10);
				const color2 = textureLoader.load(
				  "./textures/color2/roughness.jpg"
				);
				color2.wrapT = THREE.RepeatWrapping;
				color2.wrapS = THREE.RepeatWrapping;
				color2.repeat.set(10, 10);
				return {
				  none: null,
				  color1: color1,
				  color2: color2,
				};
			  })();
		
			  const alphaMaps = (function () {
				const fibers = textureLoader.load("./textures/alphaMap.jpeg");
				fibers.wrapT = THREE.RepeatWrapping;
				fibers.wrapS = THREE.RepeatWrapping;
				fibers.repeat.set(10, 10);
				const color1 = textureLoader.load("./textures/color1/opacity.jpg");
				color1.wrapT = THREE.RepeatWrapping;
				color1.wrapS = THREE.RepeatWrapping;
				color1.repeat.set(10, 10);
		
				return {
				  none: null,
				  fibers: fibers,
				  color1: color1,
				};
			  })();
			  console.log(alphaMaps)
		
			  const envMapKeys = getObjectsKeys(envMaps);
			  const envMapKeysPBR = envMapKeys.slice(0, 2);
			  const diffuseMapKeys = getObjectsKeys(diffuseMaps);
			  const roughnessMapKeys = getObjectsKeys(roughnessMaps);
			  const normalMapKeys = getObjectsKeys(normalMaps);
			  const alphaMapKeys = getObjectsKeys(alphaMaps);
			  const metalnessMapKeys = getObjectsKeys(metalnessMaps);
		
			  function generateVertexColors(geometry) {
				const positionAttribute = geometry.attributes.position;
		
				const colors = [];
				const color = new THREE.Color();
		
				for (let i = 0, il = positionAttribute.count; i < il; i++) {
				  color.setHSL((i / il) * Math.random(), 0.5, 0.5);
				  colors.push(color.r, color.g, color.b);
				}
		
				geometry.setAttribute(
				  "color",
				  new THREE.Float32BufferAttribute(colors, 3)
				);
			  }
		
			  function handleColorChange(color) {
				return function (value) {
				  if (typeof value === "string") {
					value = value.replace("#", "0x");
				  }
		
				  color.setHex(value);
				};
			  }
		
			  function needsUpdate(material, geometry) {
				return function () {
				  material.side = parseInt(material.side); //Ensure number
				  material.needsUpdate = true;
				  geometry.attributes.position.needsUpdate = true;
				  geometry.attributes.normal.needsUpdate = true;
				};
			  }
		
			  function updateCombine(material) {
				return function (combine) {
				  material.combine = parseInt(combine);
				  material.needsUpdate = true;
				};
			  }
		
			  function updateTexture(material, materialKey, textures) {
				return function (key) {
				  material[materialKey] = textures[key];
				  material.needsUpdate = true;
				};
			  }
			  function normalMapSet(material) {
				return function (key) {
				  material.normalScale = new THREE.Vector3(key, key, key);
				  material.needsUpdate = true;
				};
			  }
			  function guiScene(gui, scene) {
				const folder = gui.addFolder("Scene");

				const data = {
					background: "#000000",
					"ambient light": ambientLight.color.getHex(),
				  };
				folder.addColor(data, "ambient light").onChange(handleColorChange(ambientLight.color));
				folder.add(ambientLight, "intensity", 0, 1).name("ambient intensity");
			  }
		
			  function guiSceneFog(folder, scene) {
				const fogFolder = folder.addFolder("scene.fog");
		
				const fog = new THREE.Fog(0x3f7b9d, 0, 60);
		
				const data = {
				  fog: {
					"THREE.Fog()": false,
					"scene.fog.color": fog.color.getHex(),
				  },
				};
		
				fogFolder.add(data.fog, "THREE.Fog()").onChange(function (useFog) {
				  if (useFog) {
					scene.fog = fog;
				  } else {
					scene.fog = null;
				  }
				});
		
				fogFolder
				  .addColor(data.fog, "scene.fog.color")
				  .onChange(handleColorChange(fog.color));
			  }
		
			  function guiMaterial(gui, mesh, material, geometry) {
				const folder = gui.addFolder("THREE.Material");
		
				folder
				  .add(material, "transparent")
				  .onChange(needsUpdate(material, geometry));
				folder.add(material, "opacity", 0, 1).step(0.01);
				// folder.add(material, "depthTest");
				// folder.add(material, "depthWrite");
		
				folder.add(material, "visible");
				folder
				  .add(material, "side", constants.side)
				  .onChange(needsUpdate(material, geometry));
			  }
		
			  function guiMeshStandardMaterial(gui, mesh, material, geometry) {
				const data = {
				  color: material.color.getHex(),
				  emissive: material.emissive.getHex(),
				  envMaps: envMapKeysPBR[0],
				  map: diffuseMapKeys[0],
				  roughnessMap: roughnessMapKeys[0],
				  alphaMap: alphaMapKeys[0],
				  normalMap: normalMapKeys[0],
				  metalnessMap: metalnessMapKeys[0],
				  normalScale: 1,
				};
		
				const folder = gui.addFolder("THREE.MeshStandardMaterial");
		
				folder
				  .addColor(data, "color")
				  .onChange(handleColorChange(material.color));
				folder.add(material, "roughness", 0, 1);
				folder.add(material, "metalness", 0, 1);
				folder
				  .add(data, "normalScale", 0, 5)
				  .onChange(normalMapSet(material, material.normalScale));
				folder
				  .add(material, "alphaTest", 0, 1)
				  .step(0.01)
				  .onChange(needsUpdate(material, geometry));
				folder.add(material, "wireframe");
				// folder
				//   .add(material, "vertexColors")
				//   .onChange(needsUpdate(material, geometry));
				// folder.add(material, "fog");
				folder
				  .add(data, "map", diffuseMapKeys)
				  .onChange(updateTexture(material, "map", diffuseMaps));
				folder
				  .add(data, "normalMap", normalMapKeys)
				  .onChange(updateTexture(material, "normalMap", normalMaps));
				folder
				  .add(data, "metalnessMap", metalnessMapKeys)
				  .onChange(updateTexture(material, "metalnessMap", metalnessMaps));
				folder
				  .add(data, "roughnessMap", roughnessMapKeys)
				  .onChange(updateTexture(material, "roughnessMap", roughnessMaps));
				folder
				  .add(data, "alphaMap", alphaMapKeys)
				  .onChange(updateTexture(material, "alphaMap", alphaMaps));
				folder
				  .add(data, "envMaps", envMapKeysPBR)
				  .onChange(updateTexture(material, "envMap", envMaps));
				// TODO metalnessMap
			  }
		
			  function chooseFromHash(gui, mesh, geometry) {
				if(gui){
					gui.destroy()
					gui = new GUI();

					/*
					if(gui.folders){
						console.log(gui.folders);
						folders = gui.folders;
						for(var i = 0; i < folders.length; i++){
							gui.removeFolder(folders[i]);
						}
					} 
					*/
				}
				guiScene(gui,scene)

				let material;
				material = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });
				material.side = THREE.DoubleSide;
				guiMaterial(gui, mesh, material, geometry);
				guiMeshStandardMaterial(gui, mesh, material, geometry);
		
				// only use scene environment
				return material;
			  }






			var camera, scene, renderer, controls,material0;
			let texturePlante0,texturePlante1,texturePlante2,texturePlante3;
			let fbxModels;

			const objects = [];

			let raycaster;

			let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let canJump = false;

			let prevTime = performance.now();
			const velocity = new THREE.Vector3();
			const direction = new THREE.Vector3();
			const vertex = new THREE.Vector3();
			const color = new THREE.Color();

			var ambientLight = new THREE.AmbientLight(0x404040, 0);

			let orbitControls;


			init();
			animate();
			//createPanel();


			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 100;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );


				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 1 );
				light.position.set( 1, 1, 1 );
				scene.add( light );

      			scene.add(ambientLight);
				const light1 = new THREE.PointLight(0x777788, 1, 0);
				light1.position.set(0, 200, 0);
				scene.add(light1);
			
			
				

				controls = new PointerLockControls( camera, document.body );

				const finger = document.getElementById( 'finger' );
				const lockModuleButton = document.getElementById( 'lock-model')
				lockModuleButton.addEventListener( 'click', function () {
					controls.lock();
					if (gui){
						gui.close();
					}
				} );

				controls.addEventListener( 'lock', function () {

				    finger.style.display = 'block'
				    document.body.addEventListener('mousedown', onMouseclick, false);
				} );

				controls.addEventListener( 'unlock', function () {


					finger.style.display = 'none'
					document.body.removeEventListener('mousedown', onMouseclick, false);
				} );

				scene.add( controls.getObject() );



				const onKeyDown = function ( event ) {

					switch ( event.code ) {

						case 'ArrowUp':
						case 'KeyW':
							moveForward = true;
							break;

						case 'ArrowLeft':
						case 'KeyA':
							moveLeft = true;
							break;

						case 'ArrowDown':
						case 'KeyS':
							moveBackward = true;
							break;

						case 'ArrowRight':
						case 'KeyD':
							moveRight = true;
							break;

						case 'Space':
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};

				const onKeyUp = function ( event ) {

					switch ( event.code ) {

						case 'ArrowUp':
						case 'KeyW':
							moveForward = false;
							break;

						case 'ArrowLeft':
						case 'KeyA':
							moveLeft = false;
							break;

						case 'ArrowDown':
						case 'KeyS':
							moveBackward = false;
							break;

						case 'ArrowRight':
						case 'KeyD':
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown );
				document.addEventListener( 'keyup', onKeyUp );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

					// model
				initFbxs();
				

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize );

				orbitControls =  new OrbitControls(camera, renderer.domElement)
				orbitControls.minDistance = 10;
				orbitControls.maxDistance = 300;
				orbitControls.target.set(0, 0, -200);
				camera.lookAt(0, 0, -200);

				

			}
			function initFbxs() {
				texturePlante0 = THREE.ImageUtils.loadTexture("models/fbx/4k1_Diffuse.jpeg",null,function(t){});
					texturePlante1 = THREE.ImageUtils.loadTexture("models/fbx/4k2_Diffuse.jpeg",null,function(t){});
					texturePlante2 = THREE.ImageUtils.loadTexture("models/fbx/4k3_Diffuse.jpeg",null,function(t){});
					texturePlante3 = THREE.ImageUtils.loadTexture("models/fbx/WTS_BG2_baked.jpg",null,function(t){});
					texturePlante0.wrapS = texturePlante0.wrapT = THREE.RepeatWrapping;
					texturePlante1.wrapS = texturePlante1.wrapT = THREE.RepeatWrapping;
					texturePlante2.wrapS = texturePlante2.wrapT = THREE.RepeatWrapping;
					texturePlante3.wrapS = texturePlante3.wrapT = THREE.RepeatWrapping;


					const loader = new FBXLoader();
					loader.load( 'models/fbx/WTS_v1.fbx', function ( object ) {
						console.log(object)
						fbxModels = object;
	
						var child0 = object.children[0];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante0
						});
						child0.material=material;
						child0.material.needsUpdate = true;
						material0 = material;
	
					
	
						var child1 = object.children[1];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante0
						});
						child1.material=material;
						child1.material.needsUpdate = true;
						
						if ( child1.isMesh ) {
							child1.castShadow = true;
							child1.receiveShadow = true;
						};
	
						var child2 = object.children[2];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante0
						});
						child2.material=material;

						
						if ( child2.isMesh ) {
							child2.castShadow = true;
							child2.receiveShadow = true;
						};
	
	
						var child3 = object.children[3];
						var material = new THREE.MeshPhongMaterial({
							map:texturePlante3
						});
						child3.material=material;
						if ( child3.isMesh ) {
							child3.castShadow = true;
							child3.receiveShadow = true;
						};
	
						object.traverse( function (child){
							if(child instanceof THREE.Mesh){
							}
						});
	
						scene.add( object );
					} );

			}

			function createPanel() {
				guiScene(gui, scene);
				return
			}
			

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				render();
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
			}

			function render(){
				controlsRender();
			}

			 
    // 鼠标双击触发的方法
    function onMouseclick(event) {
		console.log(event)
		controls.unlock();
 
        // 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前
        var intersects = getIntersects(event);
 
        // 获取选中最近的 Mesh 对象
        if (intersects.length != 0 && intersects[0].object instanceof THREE.Mesh) {
            let selectObject = intersects[0].object;
			//alert("click on "+selectObject.name);
			console.log(selectObject.name)

			if(selectObject.name=='4_BG') return

			console.log(selectObject.geometry)
			//selectObject.geometry.center()
			let position = selectObject.position
			orbitControls.target.set(position.x,0,position.z);
			//orbitControls.target.set(0, 0, -200);

			console.log(gui)

			selectObject.material = chooseFromHash(gui, selectObject, selectObject.geometry);

			console.log(selectObject)
        } else {
            alert("未选中 Mesh!");
        }
    }

			 // 获取与射线相交的对象数组
			 function getIntersects(event) {
				//event.preventDefault();
		
		 
				// 声明 raycaster 和 mouse 变量
				var raycaster = new THREE.Raycaster();
				var mouse = new THREE.Vector2();
		 
				// 通过鼠标点击位置,计算出 raycaster 所需点的位置,以屏幕为中心点,范围 -1 到 1
				//mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				//mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

				mouse.x = (window.innerWidth/2 / window.innerWidth) * 2 - 1;
				mouse.y = -(window.innerHeight/2 / window.innerHeight) * 2 + 1;
		 




				//通过鼠标点击的位置(二维坐标)和当前相机的矩阵计算出射线位置
				raycaster.setFromCamera(mouse, camera);
		 
				// 获取与射线相交的对象数组，其中的元素按照距离排序，越近的越靠前
				var intersects = raycaster.intersectObjects(scene.children);
		 
				//返回选中的对象
				return intersects;
			}


			function controlsRender(){
				const time = performance.now();

				if ( controls.isLocked === true ) {

					

					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					const intersections = raycaster.intersectObjects( objects, false );

					const onObject = intersections.length > 0;

					const delta = ( time - prevTime ) / 500;

					velocity.x -= velocity.x * 5.0 * delta;//移动速度
					velocity.z -= velocity.z * 5.0 * delta;//移动速度


					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					if ( onObject === true ) {

						velocity.y = Math.max( 0, velocity.y );
						canJump = true;

					}

					controls.moveRight( - velocity.x * delta );
					controls.moveForward( - velocity.z * delta );

					controls.getObject().position.y += ( velocity.y * delta ); // new behavior

					if ( controls.getObject().position.y < 100 ) {

						velocity.y = 0;
						controls.getObject().position.y = 100;

						canJump = true;
					}

				}
				prevTime = time;
				impactCheck()
			}

			//碰撞检测
			function impactCheck(){
				//(-515,-550)(515,550)
				let position = controls.getObject().position;
				if(position.x<-515){
					controls.getObject().position.x= -515;
				}
				if(position.x>515){
					controls.getObject().position.x= 515;
				}
				if(position.z<-550){
					controls.getObject().position.z= -550;
				}
				if(position.z>550){
					controls.getObject().position.z= 550;
				}
			}

		</script>
	</body>
</html>
