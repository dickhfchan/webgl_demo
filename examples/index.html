<!DOCTYPE html5>
<html lang="en">
  <head>
    <title>demo</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      #finger {
        display: none;
        width: 20px;
        height: 20px;
        position: absolute;
        left: 50%;
        top: 50%;
      }

      dialog {
        background-color: #fdf6ec;
        border-color: #faecd8;
        color: #e6a23c;
        top: 150px;
        width: 250px;
        border-radius: 10px;
        border-width: 1px;
        transition: opacity 0.3s, transform 0.4s, -webkit-transform 0.4s;
      }
      #lock-model {
        position: absolute;
        margin-top: 10px;
        margin-left: 10px;
      }
    </style>
  </head>
  <body>
    <img id="finger" src="./images/finger.png" alt="" />
    <button id="lock-model">Enter Lock Model</button>

    <script type="module">
      import * as THREE from "../build/three.module.js";

      import { PointerLockControls } from "./jsm/controls/PointerLockControls.js";
      import { OrbitControls } from "./jsm/controls/OrbitControls.js";

      import { TransformControls } from "./jsm/controls/controls.js";

      import { FBXLoader } from "./jsm/loaders/FBXLoader.js";
      import { GUI } from "./jsm/libs/lil-gui.module.min.js";

      let gui = new GUI();

      const constants = {
        combine: {
          "THREE.MultiplyOperation": THREE.MultiplyOperation,
          "THREE.MixOperation": THREE.MixOperation,
          "THREE.AddOperation": THREE.AddOperation,
        },

        side: {
          "THREE.FrontSide": THREE.FrontSide,
          "THREE.BackSide": THREE.BackSide,
          "THREE.DoubleSide": THREE.DoubleSide,
        },
      };

      function getObjectsKeys(obj) {
        const keys = [];

        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys.push(key);
          }
        }

        return keys;
      }

      const textureLoader = new THREE.TextureLoader();
      const cubeTextureLoader = new THREE.CubeTextureLoader();

      const envMaps = (function () {
        const path = "./textures/cube/";
        const format = ".jpeg";
        const urls = [
          path + "px" + format,
          path + "nx" + format,
          path + "py" + format,
          path + "ny" + format,
          path + "pz" + format,
          path + "nz" + format,
        ];

        const reflectionCube = cubeTextureLoader.load(urls);

        const refractionCube = cubeTextureLoader.load(urls);
        refractionCube.mapping = THREE.CubeRefractionMapping;

        return {
          none: null,
          reflection: reflectionCube,
          refraction: refractionCube,
        };
      })();

      const diffuseMaps = (function () {
        const color1 = textureLoader.load("./textures/color1/diffuse.jpg");
        color1.wrapS = THREE.RepeatWrapping;
        color1.wrapT = THREE.RepeatWrapping;
        color1.repeat.set(10, 10);
        const color2 = textureLoader.load("./textures/color2/diffuse.jpg");
        color2.wrapS = THREE.RepeatWrapping;
        color2.wrapT = THREE.RepeatWrapping;
        color2.repeat.set(10, 10);

        return {
          none: null,
          color1: color1,
          color2: color2,
        };
      })();
      const normalMaps = (function () {
        const color1 = textureLoader.load("./textures/color1/normal.jpg");
        color1.wrapS = THREE.RepeatWrapping;
        color1.wrapT = THREE.RepeatWrapping;
        color1.repeat.set(10, 10);
        const color2 = textureLoader.load("./textures/color2/normal.jpg");
        color2.wrapS = THREE.RepeatWrapping;
        color2.wrapT = THREE.RepeatWrapping;
        color2.repeat.set(10, 10);

        return {
          none: null,
          color1: color1,
          color2: color2,
        };
      })();
      const metalnessMaps = (function () {
        const color1 = textureLoader.load("./textures/color1/metalness.jpg");
        color1.wrapS = THREE.RepeatWrapping;
        color1.wrapT = THREE.RepeatWrapping;
        color1.repeat.set(10, 10);
        const color2 = textureLoader.load("./textures/color2/metalness.jpg");
        color2.wrapS = THREE.RepeatWrapping;
        color2.wrapT = THREE.RepeatWrapping;
        color2.repeat.set(10, 10);

        return {
          none: null,
          color1: color1,
          color2: color2,
        };
      })();
      const roughnessMaps = (function () {
        const color1 = textureLoader.load("./textures/color2/roughness.jpg");
        color1.wrapT = THREE.RepeatWrapping;
        color1.wrapS = THREE.RepeatWrapping;
        color1.repeat.set(10, 10);
        const color2 = textureLoader.load("./textures/color2/roughness.jpg");
        color2.wrapT = THREE.RepeatWrapping;
        color2.wrapS = THREE.RepeatWrapping;
        color2.repeat.set(10, 10);
        return {
          none: null,
          color1: color1,
          color2: color2,
        };
      })();

      const alphaMaps = (function () {
        const fibers = textureLoader.load("./textures/alphaMap.jpeg");
        fibers.wrapT = THREE.RepeatWrapping;
        fibers.wrapS = THREE.RepeatWrapping;
        fibers.repeat.set(10, 10);
        const color1 = textureLoader.load("./textures/color1/opacity.jpg");
        color1.wrapT = THREE.RepeatWrapping;
        color1.wrapS = THREE.RepeatWrapping;
        color1.repeat.set(10, 10);

        return {
          none: null,
          fibers: fibers,
          color1: color1,
        };
      })();
      console.log(alphaMaps);

      const envMapKeys = getObjectsKeys(envMaps);
      const envMapKeysPBR = envMapKeys.slice(0, 2);
      const diffuseMapKeys = getObjectsKeys(diffuseMaps);
      const roughnessMapKeys = getObjectsKeys(roughnessMaps);
      const normalMapKeys = getObjectsKeys(normalMaps);
      const alphaMapKeys = getObjectsKeys(alphaMaps);
      const metalnessMapKeys = getObjectsKeys(metalnessMaps);

      function generateVertexColors(geometry) {
        const positionAttribute = geometry.attributes.position;

        const colors = [];
        const color = new THREE.Color();

        for (let i = 0, il = positionAttribute.count; i < il; i++) {
          color.setHSL((i / il) * Math.random(), 0.5, 0.5);
          colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );
      }

      function handleColorChange(color) {
        return function (value) {
          if (typeof value === "string") {
            value = value.replace("#", "0x");
          }

          color.setHex(value);
        };
      }

      function needsUpdate(material, geometry) {
        return function () {
          material.side = parseInt(material.side); //Ensure number
          material.needsUpdate = true;
          geometry.attributes.position.needsUpdate = true;
          geometry.attributes.normal.needsUpdate = true;
        };
      }

      function updateCombine(material) {
        return function (combine) {
          material.combine = parseInt(combine);
          material.needsUpdate = true;
        };
      }

      function updateTexture(material, materialKey, textures) {
        return function (key) {
          material[materialKey] = textures[key];
          material.needsUpdate = true;
        };
      }
      function normalMapSet(material) {
        return function (key) {
          material.normalScale = new THREE.Vector3(key, key, key);
          material.needsUpdate = true;
        };
      }
      function guiScene(gui, scene) {
        const folder = gui.addFolder("Scene");

        const data = {
          background: "#000000",
          " SpotLight power": spotLight.power,
        };
        folder.add(spotLight, "power", 0, 50).step(1).name("SpotLight power");
      }

      function guiSceneFog(folder, scene) {
        const fogFolder = folder.addFolder("scene.fog");

        const fog = new THREE.Fog(0x3f7b9d, 0, 60);

        const data = {
          fog: {
            "THREE.Fog()": false,
            "scene.fog.color": fog.color.getHex(),
          },
        };

        fogFolder.add(data.fog, "THREE.Fog()").onChange(function (useFog) {
          if (useFog) {
            scene.fog = fog;
          } else {
            scene.fog = null;
          }
        });

        fogFolder
          .addColor(data.fog, "scene.fog.color")
          .onChange(handleColorChange(fog.color));
      }

      function guiMaterial(gui, mesh, material, geometry) {
        const folder = gui.addFolder("THREE.Material");

        folder
          .add(material, "transparent")
          .onChange(needsUpdate(material, geometry));
        folder.add(material, "opacity", 0, 1).step(0.01);
        // folder.add(material, "depthTest");
        // folder.add(material, "depthWrite");

        folder.add(material, "visible");
        folder
          .add(material, "side", constants.side)
          .onChange(needsUpdate(material, geometry));
      }

      function guiMeshStandardMaterial(gui, mesh, material, geometry) {
        const data = {
          color: material.color.getHex(),
          emissive: material.emissive.getHex(),
          envMaps: envMapKeysPBR[0],
          map: diffuseMapKeys[0],
          roughnessMap: roughnessMapKeys[0],
          alphaMap: alphaMapKeys[0],
          normalMap: normalMapKeys[0],
          metalnessMap: metalnessMapKeys[0],
          normalScale: 1,
        };

        const folder = gui.addFolder("THREE.MeshStandardMaterial");

        folder
          .addColor(data, "color")
          .onChange(handleColorChange(material.color));
        folder.add(material, "roughness", 0, 1);
        folder.add(material, "metalness", 0, 1);
        folder
          .add(data, "normalScale", 0, 5)
          .onChange(normalMapSet(material, material.normalScale));
        folder
          .add(material, "alphaTest", 0, 1)
          .step(0.01)
          .onChange(needsUpdate(material, geometry));
        folder.add(material, "wireframe");
        // folder
        //   .add(material, "vertexColors")
        //   .onChange(needsUpdate(material, geometry));
        // folder.add(material, "fog");
        folder
          .add(data, "map", diffuseMapKeys)
          .onChange(updateTexture(material, "map", diffuseMaps));
        folder
          .add(data, "normalMap", normalMapKeys)
          .onChange(updateTexture(material, "normalMap", normalMaps));
        folder
          .add(data, "metalnessMap", metalnessMapKeys)
          .onChange(updateTexture(material, "metalnessMap", metalnessMaps));
        folder
          .add(data, "roughnessMap", roughnessMapKeys)
          .onChange(updateTexture(material, "roughnessMap", roughnessMaps));
        folder
          .add(data, "alphaMap", alphaMapKeys)
          .onChange(updateTexture(material, "alphaMap", alphaMaps));
        folder
          .add(data, "envMaps", envMapKeysPBR)
          .onChange(updateTexture(material, "envMap", envMaps));
        // TODO metalnessMap
      }

      function chooseFromHash(gui, mesh, geometry) {
        if (gui) {
          gui.destroy();
          gui = new GUI();

          /*
        if(gui.folders){
        	console.log(gui.folders);
        	folders = gui.folders;
        	for(var i = 0; i < folders.length; i++){
        		gui.removeFolder(folders[i]);
        	}
        }
        */
        }
        guiScene(gui, scene);

        let material;
        material = new THREE.MeshStandardMaterial({ color: 0xffffff });
        material.side = THREE.DoubleSide;
        guiMaterial(gui, mesh, material, geometry);
        guiMeshStandardMaterial(gui, mesh, material, geometry);

        // only use scene environment
        return material;
      }

      var camera, scene, renderer, controls, material0;
      let texturePlante0, texturePlante1, texturePlante2, texturePlante3;
      let fbxModels;

      const objects = [];

      let raycaster;

      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;

      let prevTime = performance.now();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const vertex = new THREE.Vector3();
      const color = new THREE.Color();

      var ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      let spotLight;
      let orbitControls;
	  let transformControls;

      init();
      animate();
      //createPanel();

      function init() {
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          2000
        );
        camera.position.y = 100;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 1);
        // light.position.set(1, 1, 1);
        // scene.add(light);

        // const helper = new THREE.HemisphereLightHelper(light, 5);
        // scene.add(helper);
        const light = new THREE.PointLight(0xffffff);
        light.position.set(0, 200, 0);
        scene.add(light);
        const sphereSize = 1;
        const pointLightHelper = new THREE.PointLightHelper(light, sphereSize);
        scene.add(pointLightHelper);
        scene.add(ambientLight);

        controls = new PointerLockControls(camera, document.body);

        const finger = document.getElementById("finger");
        const lockModuleButton = document.getElementById("lock-model");
        lockModuleButton.addEventListener("click", function () {
          controls.lock();
		  if(transformControls){
			  transformControls.detach();
		  }
          if (gui) {
            gui.close();
          }
        });

        controls.addEventListener("lock", function () {
          finger.style.display = "block";
          document.body.addEventListener("mousedown", onMouseclick, false);
        });

        controls.addEventListener("unlock", function () {
          finger.style.display = "none";
          document.body.removeEventListener("mousedown", onMouseclick, false);
        });

        scene.add(controls.getObject());

        const onKeyDown = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW":
              moveForward = true;
              break;

            case "ArrowLeft":
            case "KeyA":
              moveLeft = true;
              break;

            case "ArrowDown":
            case "KeyS":
              moveBackward = true;
              break;

            case "ArrowRight":
            case "KeyD":
              moveRight = true;
              break;

            case "Space":
              if (canJump === true) velocity.y += 350;
              canJump = false;
              break;
          }
        };

        const onKeyUp = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW":
              moveForward = false;
              break;

            case "ArrowLeft":
            case "KeyA":
              moveLeft = false;
              break;

            case "ArrowDown":
            case "KeyS":
              moveBackward = false;
              break;

            case "ArrowRight":
            case "KeyD":
              moveRight = false;
              break;
          }
        };

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        raycaster = new THREE.Raycaster(
          new THREE.Vector3(),
          new THREE.Vector3(0, -1, 0),
          0,
          10
        );

        // model

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener("resize", onWindowResize);

        orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.minDistance = 10;
        orbitControls.maxDistance = 10300;
        orbitControls.target.set(0, 0, -200);
        camera.lookAt(0, 0, -200);

		transformControls = new TransformControls(camera, renderer.domElement);
		transformControls.setMode( "rotate" );//
		transformControls.showY = true;
		scene.add(transformControls);

        initFbxs();

      }
      function initFbxs() {
        texturePlante0 = THREE.ImageUtils.loadTexture(
          "models/fbx/4k1_Diffuse.jpeg",
          null,
          function (t) {}
        );
        texturePlante1 = THREE.ImageUtils.loadTexture(
          "models/fbx/4k2_Diffuse.jpeg",
          null,
          function (t) {}
        );
        texturePlante2 = THREE.ImageUtils.loadTexture(
          "models/fbx/4k3_Diffuse.jpeg",
          null,
          function (t) {}
        );
        texturePlante3 = THREE.ImageUtils.loadTexture(
          "models/fbx/WTS_BG2_baked.jpg",
          null,
          function (t) {}
        );
        texturePlante0.wrapS = texturePlante0.wrapT = THREE.RepeatWrapping;
        texturePlante1.wrapS = texturePlante1.wrapT = THREE.RepeatWrapping;
        texturePlante2.wrapS = texturePlante2.wrapT = THREE.RepeatWrapping;
        texturePlante3.wrapS = texturePlante3.wrapT = THREE.RepeatWrapping;

        const loader = new FBXLoader();
        loader.load("models/fbx/WTS_v1.fbx", function (object) {
          console.log(object);
          fbxModels = object;

          var child0 = object.children[0];
          var material = new THREE.MeshStandardMaterial({
            map: texturePlante0,
          });
          child0.material = material;
          child0.material.needsUpdate = true;
          material0 = material;
          if (child0.isMesh) {
            child0.castShadow = true;
            child0.receiveShadow = true;
          }
          var child1 = object.children[1];
          var material = new THREE.MeshStandardMaterial({
            map: texturePlante0,
          });
          child1.material = material;
          child1.material.needsUpdate = true;

          if (child1.isMesh) {
            child1.castShadow = true;
            child1.receiveShadow = true;
          }

          var child2 = object.children[2];
          var material = new THREE.MeshStandardMaterial({
            map: texturePlante0,
          });
          child2.material = material;

          child2.castShadow = true;
          child2.receiveShadow = true;

          spotLight = new THREE.SpotLight(0xffffff);
          spotLight.intensity = 0.6;
          spotLight.angle = Math.PI / 5;
          spotLight.distance = 300;
          spotLight.power = 1;
          spotLight.position.set(0, 200, -100);
          spotLight.target = child2;
          spotLight.penumbra = 0.9;
          spotLight.castShadow = true;

          scene.add(spotLight);
		  
         // const spotLightHelper = new THREE.SpotLightHelper(spotLight);
         // scene.add(spotLightHelper);

          var child3 = object.children[3];
          var material = new THREE.MeshStandardMaterial({
            map: texturePlante3,
          });
          child3.material = material;
          child3.castShadow = true;
          child3.receiveShadow = true;

          object.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
            }
          });

          scene.add(object);
        });
      }

      function createPanel() {
        guiScene(gui, scene);
        return;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        render();
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      function render() {
        controlsRender();
      }

      // 鼠标双击触发的方法
      function onMouseclick(event) {
        console.log(event);
        controls.unlock();

        // 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前
        var intersects = getIntersects(event);

		console.log(intersects)
        // 获取选中最近的 Mesh 对象
        if (
          intersects.length != 0 &&
          intersects[2].object instanceof THREE.Mesh
        ) {
          let selectObject = intersects[2].object;
          //alert("click on "+selectObject.name);
          console.log(selectObject.name);

          if (selectObject.name == "4_BG") return;

          console.log(selectObject.geometry);
          //selectObject.geometry.center()
          let position = selectObject.position;
          orbitControls.target.set(position.x, 0, position.z);
          //orbitControls.target.set(0, 0, -200);

		  orbitControls.enabled = false;
		  transformControls.attach( selectObject );
		 


          console.log(gui);

          selectObject.material = chooseFromHash(
            gui,
            selectObject,
            selectObject.geometry
          );

          console.log(selectObject);
        } else {
          alert("未选中 Mesh!");
        }
      }

      // 获取与射线相交的对象数组
      function getIntersects(event) {
        //event.preventDefault();

        // 声明 raycaster 和 mouse 变量
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        // 通过鼠标点击位置,计算出 raycaster 所需点的位置,以屏幕为中心点,范围 -1 到 1
        //mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        mouse.x = (window.innerWidth / 2 / window.innerWidth) * 2 - 1;
        mouse.y = -(window.innerHeight / 2 / window.innerHeight) * 2 + 1;

        //通过鼠标点击的位置(二维坐标)和当前相机的矩阵计算出射线位置
        raycaster.setFromCamera(mouse, camera);

        // 获取与射线相交的对象数组，其中的元素按照距离排序，越近的越靠前
        var intersects = raycaster.intersectObjects(scene.children);

        //返回选中的对象
        return intersects;
      }

      function controlsRender() {
        const time = performance.now();

        if (controls.isLocked === true) {
          raycaster.ray.origin.copy(controls.getObject().position);
          raycaster.ray.origin.y -= 10;

          const intersections = raycaster.intersectObjects(objects, false);

          const onObject = intersections.length > 0;

          const delta = (time - prevTime) / 500;

          velocity.x -= velocity.x * 5.0 * delta; //移动速度
          velocity.z -= velocity.z * 5.0 * delta; //移动速度

          velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize(); // this ensures consistent movements in all directions

          if (moveForward || moveBackward)
            velocity.z -= direction.z * 400.0 * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

          if (onObject === true) {
            velocity.y = Math.max(0, velocity.y);
            canJump = true;
          }

          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);

          controls.getObject().position.y += velocity.y * delta; // new behavior

          if (controls.getObject().position.y < 100) {
            velocity.y = 0;
            controls.getObject().position.y = 100;

            canJump = true;
          }
        }
        prevTime = time;
        impactCheck();
      }

      //碰撞检测
      function impactCheck() {
        //(-515,-550)(515,550)
        let position = controls.getObject().position;
        if (position.x < -515) {
          controls.getObject().position.x = -515;
        }
        if (position.x > 515) {
          controls.getObject().position.x = 515;
        }
        if (position.z < -550) {
          controls.getObject().position.z = -550;
        }
        if (position.z > 550) {
          controls.getObject().position.z = 550;
        }
      }
    </script>
  </body>
</html>
